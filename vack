#!/bin/sh
set -eu

VACK_PATH=${VACK_PATH-$HOME/.vim/pack/vack}

usage() {
  cat <<__USAGE__ >&2
usage: ${0##*/} <command> [...]
manage Vim packages.

commands:
  i|install [-oshH] <repository>...   # install the packages
  u|update [-ahH] <package>...        # update the packages
  r|remove <package>...               # remove the packages
  l|list [-aos]                       # list installed packages
  p|path [-a] <package>...            # show install directory of the package
  e|enable <package>...               # move the packages to start
  d|disable <package>...              # move the packages to opt
  I|init                              # create the package directory
  h|help                              # show this help message

environment-variables:
  VACK_PATH   # the package directory (default: \$HOME/.vim/pack/vack)
__USAGE__
}

warn() {
  printf "%s\n" "${0##*/}: $*" >&2
}

to_start_package_path() {
  package=$1
  printf "%s\n" "$VACK_PATH/start/${package##*/}"
}

to_opt_package_path() {
  package=$1
  printf "%s\n" "$VACK_PATH/opt/${package##*/}"
}

to_installed_package_path() {
  package=$1
  start=$(to_start_package_path "$package")
  opt=$(to_opt_package_path "$package")
  if [ -d "$start" ]; then
    printf "%s\n" "$start"
  elif [ -d "$opt" ]; then
    printf "%s\n" "$opt"
  else
    echo
  fi
}

to_destination_package_path() {
  package=$1
  package_type=$2
  case $package_type in
    start) printf "%s\n" "$(to_start_package_path "$package")" ;;
    opt)   printf "%s\n" "$(to_opt_package_path "$package")" ;;
    *)     echo ;;
  esac
}

to_source_url() {
  package=$1
  printf "%s\n" "$package" | awk '
    /^[^\/]+$/                 { print "git://github.com/vim-scripts/" $0; next }
    /^[^\/]+\/[^\/]+$/         { print "git://github.com/" $0; next }
    /^[^\/]+\/[^\/]+\/[^\/]+$/ { print "git://" $0; next }
                               { print $0; next }
  '
}

list_start_package() {
  ls -- "$VACK_PATH/start" | cat
}

list_opt_package() {
  ls -- "$VACK_PATH/opt" | cat
}

list_all_package() {
  list_start_package
  list_opt_package
}

list_all_package_path() {
  for path in "$VACK_PATH/start/"* "$VACK_PATH/opt/"*; do
    if [ -d "$path" ]; then
      printf "%s\n" "$path"
    fi
  done
}


helptags() {
  package_path=$1
  doc_path=$package_path/doc
  if [ -d "$doc_path" ]; then
    vim +"helptags $doc_path" +"qa"
  fi
}

cmd_install() {
  package_type=start
  do_helptags=true
  while getopts "oshH" OPT; do
    case $OPT in
      s) package_type=start ;;
      o) package_type=opt ;;
      h) do_helptags=true ;;
      H) do_helptags=false ;;
      *) exit 2 ;;
    esac
  done
  shift $(($OPTIND - 1))

  if [ $# -lt 1 ]; then
    warn "no input packages"
    exit 2
  fi

  for package in "$@"; do
    src_url=$(to_source_url "$package")
    dst_path=$(to_destination_package_path "$package" "$package_type")
    if [ ! -d "$dst_path" ]; then
      git clone --quiet --depth=1 -- "$src_url" "$dst_path"
    fi
    if "$do_helptags"; then
      helptags "$dst_path"
    fi
  done
}

cmd_update() {
  update_all=false
  do_helptags=false
  while getopts "ahH" OPT; do
    case $OPT in
      a) update_all=true ;;
      h) do_helptags=true ;;
      H) do_helptags=false ;;
      *) exit 2 ;;
    esac
  done
  shift $(($OPTIND - 1))

  if ! "$update_all" && [ $# -lt 1 ]; then
    warn "no input packages"
    exit 2
  fi

  if "$update_all"; then
    for path in "$VACK_PATH/start/"* "$VACK_PATH/opt/"*; do
      if [ -d "$path" ]; then
        (cd "$path"; git pull --quiet --no-ff)
      fi
      if "$do_helptags"; then
        helptags "$path"
      fi
    done
  else
    for package in "$@"; do
      path=$(to_installed_package_path "$package")
      if [ -d "$path" ]; then
        (cd "$path"; git pull --quiet --no-ff)
      fi
      if "$do_helptags"; then
        helptags "$path"
      fi
    done
  fi
}

cmd_remove() {
  while getopts "" OPT; do
    case $OPT in
      *) exit 2 ;;
    esac
  done
  shift $(($OPTIND - 1))

  if [ $# -lt 1 ]; then
    warn "no input packages"
    exit 2
  fi

  for package in "$@"; do
    path=$(to_installed_package_path "$package")
    if [ -d "$path" ]; then
      rm -rf -- "$path"
    fi
  done
}

cmd_list() {
  package_type=all
  while getopts "aos" OPT; do
    case $OPT in
      a) package_type=all ;;
      s) package_type=start ;;
      o) package_type=opt ;;
      *) exit 2 ;;
    esac
  done
  shift $(($OPTIND - 1))

  case $package_type in
    all)   list_all_package   ;;
    start) list_start_package ;;
    opt)   list_opt_package   ;;
  esac
}

cmd_path() {
  show_all=false
  while getopts "a" OPT; do
    case $OPT in
      a) show_all=true ;;
      *) exit 2 ;;
    esac
  done
  shift $(($OPTIND - 1))

  if ! "$show_all" && [ $# -lt 1 ]; then
    warn "no input packages"
    exit 2
  fi

  if "$show_all"; then
    list_all_package_path
  else
    for package in "$@"; do
      path=$(to_installed_package_path "$package")
      if [ -d "$path" ]; then
        printf "%s\n" "$path"
      fi
    done
  fi
}

cmd_enable() {
  while getopts "" OPT; do
    case $OPT in
      *) exit 2 ;;
    esac
  done
  shift $(($OPTIND - 1))

  if [ $# -lt 1 ]; then
    warn "no input packages"
    exit 2
  fi

  for package in "$@"; do
    src=$(to_opt_package_path "$package")
    dst=$(to_start_package_path "$package")
    if [ -d "$src" ] && [ ! -d "$dst" ]; then
      mv -- "$src" "$dst"
    fi
  done
}

cmd_disable() {
  while getopts "" OPT; do
    case $OPT in
      *) exit 2 ;;
    esac
  done
  shift $(($OPTIND - 1))

  if [ $# -lt 1 ]; then
    warn "no input packages"
    exit 2
  fi

  for package in "$@"; do
    src=$(to_start_package_path "$package")
    dst=$(to_opt_package_path "$package")
    if [ -d "$src" ] && [ ! -d "$dst" ]; then
      mv -- "$src" "$dst"
    fi
  done
}

cmd_init() {
  while getopts "" OPT; do
    case $OPT in
      *) exit 2 ;;
    esac
  done
  shift $(($OPTIND - 1))

  mkdir -p -- "$VACK_PATH"
  mkdir -p -- "$VACK_PATH/start"
  mkdir -p -- "$VACK_PATH/opt"
}

cmd_help() {
  while getopts "" OPT; do
    case $OPT in
      *) exit 2 ;;
    esac
  done
  shift $(($OPTIND - 1))

  usage 2>&1
}

main() {
  if [ $# -lt 1 ]; then
    usage
    exit 2
  fi

  cmd=$1
  shift
  case $cmd in
    i|install) cmd_install "$@" ;;
    u|update)  cmd_update  "$@" ;;
    r|remove)  cmd_remove  "$@" ;;
    l|list)    cmd_list    "$@" ;;
    p|path)    cmd_path    "$@" ;;
    e|enable)  cmd_enable  "$@" ;;
    d|disable) cmd_disable "$@" ;;
    I|init)    cmd_init    "$@" ;;
    h|help)    cmd_help    "$@" ;;
    *) warn "$cmd: sub command not found"; exit 2 ;;
  esac
}

main "$@"
